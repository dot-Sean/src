-*- coding: utf-8 -*-

Haskell は、非正格関数型プログラミング言語 (non-strict functional programming languages)。非正格関数は「遅延関数 (lazy function)」とも呼ばれ、実際に値が必要になるまでは、その評価方法が保持されるだけで、評価はされない。

let i = i in 1 は 1 だが、let i = i in i は終わらない。"=" で行われたのは、代入ではなく、結束、あるいは定義にすぎない。

自然数の無限リストの 0 番目は 1。先行評価型の言語では出来ないことを平然とやってのける。

let numsFrom n = n : numsFrom (n + 1); naturals = numsFrom 1 in naturals !! 0

フィボナッチ数列が以下のように定義できてしまう。

fib = 0 : 1 : [ a + b | (a, b) <- zip fib (tail fib) ]

ここまできてようやく、「関数型言語は、代入ではなく定義で計算をする」の意味が分かる。6c6c6c6c

----------------------------------------------------------------------

関数合成…これ、大学のどこかで習った記憶があるぞ。

(.) :: (b -> c) -> (a -> b) -> (a -> c)
let inc1 = \ x -> x + 1; inc2 = \ x -> x + 2; inc3 = inc1 . inc2 in inc3 4

----------------------------------------------------------------------

中置演算子は、記号からなる。記号は、何でも使えるのな…
let (+-*/) :: [a] -> [a] -> [a]; [] +-*/ ys = ys; (x:xs) +-*/ ys = x : (xs ++ ys) in [1, 2, 3] +-*/ [7, 8, 9]

中置演算子の部分適用も可能。括弧必須
let inc = (+ 1) in inc 3

----------------------------------------------------------------------

lambda 関数の書き方。"\" を第一引数にくっつけちゃってる例をよく見かけるけど、この "\" は「λ」の代わりだから、くっつけちゃダメだよな？

let add = \ x y -> x + y; inc = \ x -> add x 1 in inc 3

add = (lambda x, y: x + y); inc = (lambda x: add(x, 1)); inc(3)

----------------------------------------------------------------------

普通の言語的には、関数の定義はこうなるけど、
let add x y = x + y; inc x = add 1 x in add 3 4

Haskell の関数は curry 化関数なので、こう書ける。
let add x y = x + y; inc = add 1 in add 4 5

カリー化関数への引数の部分適用 (partial application) とか言うらしい。

----------------------------------------------------------------------

let len [] = 0; len (x:xs) = 1 + len xs in len [3..7]
