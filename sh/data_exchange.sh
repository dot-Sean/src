#!/bin/bash
# -*- coding: utf-8 -*-

# --------------------------------------------------------------------

s=""

# 改行で区切られた入出力 ←→ 改行で区切られた文字列、は簡単だ
s=$(find . -name "*.txt")
echo "d: $s"

# --------------------------------------------------------------------

s=""
s=$(find . -name "*.txt")

# 改行で区切られた文字列 ←→ 行ごとに格納された配列
{ IFS=$'\n' read -d "" -a a; } <<< "$s"
# subshell 1 段
s=$(IFS=$'\n'; echo "${a[*]}")

# subshell 1 段。コストは変わらないが、escape が汚い…
s=$(IFS=$'\n' eval echo \"d: \${a[*]}\")

# これだと、subshell の下で cat と、subshell 2 段になり高コスト
s=$(IFS=$'\n' cat <<< "${a[*]}")

echo "d: $s"

# --------------------------------------------------------------------

a=()

# 改行で区切られた入出力 ←→ 行ごとに格納された配列
{ IFS=$'\n' read -d "" -a a; } < <(find . -name "*.txt")
(IFS=$'\n'; echo "d: ${a[*]}")

# これは、subshell を作らないので低コストなのだが、記述が、文字列に
# 落とす場合と異なるので感心しない。読みづらいし
IFS=$'\n' eval echo \"d: \${a[*]}\"
